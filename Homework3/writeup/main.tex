\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}
\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}
\usepackage{titling}
\usepackage{listings}
\usepackage{hyperref}

\usepackage{geometry}
\geometry{textheight=9.5in, textwidth=7in}

\renewcommand{\lstlistingname}{Code}

\title{Homework Assignment 3\\\large CS444 Spring 2018}
\author{Brennan Douglas, Cooper Hutchins, Nicholas Giles}
\date{May 14, 2018}


\begin{document}
\begin{titlingpage}
			\maketitle
      \begin{abstract}
			\noindent Homework 3 required the figuring out how to wrap the crypto API around a simple block driver that implemented a ram disk.
      \end{abstract}
\end{titlingpage}

\newpage
\pagenumbering{arabic}

\clearpage
\singlespace


% Document body
\section{Design}
We grabbed a standard block driver that implements a ram disk. \cite{block_driver} From there, we decided that the best time to encode our data was before it was getting written, and the best time to decode the data was when it was being read. Next to account for extra encryption data, we decided to use the function call crypto\textunderscore cipher\textunderscore blocksize which returns the size of the block of the ram disk. Finally, we decided it would be best to grab the block size for both reading and writing to the disk, and once we grabbed the block we would then encrypt or decrypt all of the data one block at a time.

\section {Answers}
\subsection{What do you think the main point of this assignment is?}
The main point of this assignment is to better understand the Linux kernel and kernel programming as a whole. For this assignment, the major idea to be grasped was the importance of encrypting data even if it is to be stored on a block hardware device. Another point of the assignment was to familiarize us with block drivers, and more importantly where the read and write calls are in the block drivers. Furthermore, another point of this assignment was to show how easily drivers can be mounted and unmounted in Linux.

\subsection{How did you personally approach the problem? Design decisions, algorithm, etc.}
The major design decision we made was where to put the encryption and decryption calls. The obvious answer that we found was to either encrypt\decrypt the data from the moment the operation was determined whether it was a read or a write call.

\subsection{How did you ensure your solution was correct? Testing details, for instance. Ensure this is written in a way that the TAs can follow to ensure correctness.}
We tested our solution by hexdumping data generated by the driver and using the cat function to print out this data, and observing that data for patterns matching the data we put into the program.

\begin{enumerate}
    \item Apply provided patch to kernel
	\item Make VM:
	\begin{itemize}
	    \item cd \textless kernel\textunderscore base\textundersore path\textgreater
        \item make clean && make -j4 all \textgreater ../build.out
        \item Optional, from another shell in same directory: tailf ../build.out
	\end{itemize}

    \item Run VM (from the kernel source's parent folder):
    \begin{itemize}
        \item source environment-setup-i586-poky-linux
        \item qemu-system-i386 -redir tcp:5532::22 -nographic -kernel linux-yocto-3.19/arch/x86/boot/bzImage -drive file=core-image-lsb-sdk-qemux86.ext4 -enable-kvm -usb -localtime --no-reboot --append "root=/dev/hda rwconsole=ttyS0 debug"
        \item Login with "root"
    \end{itemize}
    
    \item On server:
    \begin{itemize}
        \item cd \textless kernel\textunderscore base\textundersore path\textgreater /drivers/block/sbd
        \item make
        \item scp -P 5532 sbd.ko root@localhost:~
    \end{itemize}

    \item In another shell (after vm running - see below):
    \begin{itemize}
        \item ssh -p 5532 root@localhost
        \item tailf /var/log/syslog | grep sbd
    \end{itemize}

    \item In VM (from running instance above):
    \begin{itemize}
        \item insmod sbd.ko
        \item lsmod
        \item shred -z /dev/sbd0
        \item mkfs.ext2 /dev/sbd0
        \item mount /dev/sbd0 /mnt
        \item lsmod
        \item sync \&\& echo 3 \textgreater /proc/sys/vm/drop\textunderscore caches
        \item grep -a ``test`` /dev/sbd0
        \item cat /dev/sbd0 | hexdump -C
        \item cd /mnt
        \item vi testfile
        \item Add: “This is a test string!”
        \item Write and quit: “:wq”
        \item sync \&\& echo 3 \textgreater /proc/sys/vm/drop\textunderscore caches
        \item grep -a ``test`` /dev/sbd0
        \item cat /dev/sbd0 | hexdump -C
        \item rm testfile
        \item cd ..
        \item umount /mnt
        \item rmmod sbd.ko
        \item lsmod
    \end{itemize}

\end{enumerate}

\subsection{What did you learn?}
We learned that the cat function will cache its data by default, to make less work for the program when called multiple times, which led to anomalies when testing our solution for correctness. We learned that improperly reading raw data generated by the block driver will cause some… very strange behavior on the part of whatever terminal is attempting to interpret that data. We also learned how to hexdump data.

\section{Git Log}

This is our git log for the work completed on the kernel.

\begin{center}
	\begin{tabular}{ |c|c|c|p{8cm}| }
	    \hline
		\href{git://git.yoctoproject.org/linux-yocto-3.19/commit/341e1b6122797e25c446bd84dda4473c504f60f6}{341e1b6} & 2018-05-10 17:17:25 -0700 & Brennan Douglas & started hw2 template\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/279b829994a2c1ff996bb2a5bb441e57bffe3df9}{279b829} & 2018-05-10 19:15:29 -0700 & Brennan Douglas & fixing errors\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/e308a1ccd4142f64d2e568b4dd9de92b7b2f901a}{e308a1c} & 2018-05-10 19:17:26 -0700 & Brennan Douglas & updated makefile\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/2ea99de6eeaade10b70a8e8ad822405d25f6eda7}{2ea99de} & 2018-05-10 19:18:04 -0700 & Brennan Douglas & Merge branch 'hw3' of /scratch/spring2018/32/linux-yocto-3.19 into hw3\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/fa6e9d2989c0c9752a38e7fdefd87ee304b781cc}{fa6e9d2} & 2018-05-10 20:49:26 -0700 & Brennan Douglas & updated local version\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/44066bafc858595ea95bd7227cc6637673cb7eed}{44066ba} & 2018-05-10 21:34:24 -0700 & Brennan Douglas & completed intial crypto implmentation (trial)\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/98be1f6e76096fc17a2c40f06f5081b327382c4f}{98be1f6} & 2018-05-10 21:43:44 -0700 & Brennan Douglas & Merge branch 'hw3' of /scratch/spring2018/32/linux-yocto-3.19 into hw3\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/531cc94eb8a2cabb87476638d7c28d4fba04f059}{531cc94} & 2018-05-10 21:46:07 -0700 & Brennan Douglas & fixed compile errors\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/f3a2873b2a5e76ebd3b8aea81ec216c84eea93d7}{f3a2873} & 2018-05-10 21:46:52 -0700 & Brennan Douglas & fixed another compile error\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/0105912e9f4f6655a68849b077efb268900fa01a}{0105912} & 2018-05-14 19:19:15 -0700 & Brennan Douglas & print key\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/ce33484d115c12f0e2824d76c6aebc021604f82a}{ce33484} & 2018-05-14 19:22:36 -0700 & Brennan Douglas & moved sbd folder\\\hline
        \href{git://git.yoctoproject.org/linux-yocto-3.19/commit/7e00d491c226440323006259b1feca61f0cd65cf}{7e00d49} & 2018-05-14 19:28:36 -0700 & Brennan Douglas & removed old files\\\hline
	\end{tabular}
\end{center}

\section{Work Log}

Besides for the git log we had two 2 hour long meetings were we worked together on the code, research, and writeup.

\bibliographystyle{IEEEtran}
\bibliography{./ref}

\end{document}
